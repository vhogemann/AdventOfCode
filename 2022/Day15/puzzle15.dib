#!meta

{"kernelInfo":{"defaultKernelName":null,"items":[{"name":"csharp","languageName":"C#","aliases":["c#","cs"]},{"name":"fsharp","languageName":"F#","aliases":["f#","fs"]},{"name":"pwsh","languageName":"PowerShell","aliases":["powershell"]},{"name":"javascript","languageName":"JavaScript","aliases":["js"]},{"name":"html","languageName":"HTML"},{"name":"sql","languageName":"SQL"},{"name":"kql","languageName":"KQL"},{"name":"mermaid","languageName":"Mermaid"},{"name":"httpRequest","languageName":"http"},{"name":"value"}]}}

#!fsharp

#r "nuget:SharpVG"
open SharpVG    

type Pos = { 
    x: int 
    y: int 
}
type Range = {
    distance: int
    top: Pos
    bottom: Pos
    left: Pos
    right: Pos
}
type Sensor = { 
    pos: Pos
    beacon: Pos
    range: Range
}
module Sensor =
    open System.Text.RegularExpressions

    let regex = 
        Regex("Sensor at x=(?<sx>-?\d+), y=(?<sy>-?\d+): closest beacon is at x=(?<bx>-?\d+), y=(?<by>-?\d+)")

    let range (sensor:Pos) (beacon: Pos) =
        let distance =
            Math.Abs(sensor.x - beacon.x) +
            Math.Abs(sensor.y - beacon.y)

        let top = { sensor with y = sensor.y - distance }
        let bottom = { sensor with y = sensor.y + distance }
        let left = { sensor with x = sensor.x - distance }
        let right = { sensor with x = sensor.x + distance }
        
        top, bottom, left, right, distance

    let parse line =
        regex.Matches(line)
        |> Seq.map (fun m -> 
            let sx = m.Groups.["sx"].Value |> int
            let sy = m.Groups.["sy"].Value |> int
            let bx = m.Groups.["bx"].Value |> int
            let by = m.Groups.["by"].Value |> int
            let sensor = { x = sx; y = sy } 
            let beacon = { x = bx; y = by } 
            let top, bottom, left, right, distance = range sensor beacon
            { 
                pos = sensor
                beacon = beacon
                range = { 
                    top = top
                    left = left
                    bottom = bottom
                    right = right
                    distance = distance 
                } 
            }
        )
        |> Seq.head
    
    let beaconsAt line (sensors:Sensor seq) =
        sensors
        |> Seq.filter (fun it -> it.beacon.y = line )
        |> Seq.map (fun it -> it.beacon)
        |> Set.ofSeq
        |> Seq.length

type Slice =
| Start of int
| End of int
module Slice =

    let intersect line sensors =
        let merge slices (sa:Slice, ea:Slice) =
            [ sa; ea ]
            |> Seq.append slices

        let i_aux line range =
            if line >= range.top.y && line <= range.bottom.y then 
                let s = range.distance - line
                let e = range.distance + line
                Some (Start s, End e)
            else 
                None

        let compact slices =
            let rec c_aux stack acc slices =
                match slices with 
                | [] -> acc
                | head :: tail ->
                    match head with
                    | Start s when stack = 0 -> c_aux (stack + 1) ([head] |> Seq.append acc) tail
                    | Start _ -> c_aux (stack + 1) acc tail
                    | End e when stack = 1 -> c_aux 0 ([head] |> Seq.append acc) tail
                    | End _ -> c_aux (stack - 1) acc tail
            c_aux 0 List.empty (slices |> List.ofSeq)

        sensors
        |> Seq.map (fun it -> it.range |> i_aux line )
        |> Seq.choose id
        |> Seq.fold merge Seq.empty
        |> Seq.sortBy (fun it -> match it with Start s -> s | End e -> e )
        |> compact

    let sum slices =
        let rec s_aux slices acc =
            match slices with
            | [] -> acc
            | head :: tail ->
                match head with 
                | Start s -> s_aux tail (acc - s)
                | End e -> s_aux tail (acc + e)
        s_aux (slices|>List.ofSeq) 0

#!fsharp

module Preview =
    open SharpVG    
    
    let showSvg svg = display(HTML(Svg.toString svg))

    let point (p:Pos) = (p.x ,p.y ) |> Point.ofInts

    let dimensions (sensors:Sensor seq) =
        let pt p =  (p.x ,p.y)
        let points =
            sensors
            |> Seq.map (fun it -> seq { 
                yield pt it.pos
                yield pt it.beacon
                yield pt it.range.top  
                yield pt it.range.bottom  
                yield pt it.range.left  
                yield pt it.range.right
            })
            |> Seq.concat
        let top, bottom =
            let lines = points |> Seq.map snd |> Seq.sort
            lines |> Seq.head, lines |> Seq.last
        let left, right =
            let columns = points |> Seq.map fst |> Seq.sort
            columns |> Seq.head, columns |> Seq.last

        (Point.ofInts(left, top)), (Point.ofInts(right, bottom))

    let sensor (s:Sensor) =
        let centre = point s.pos
        let style = Style.create (Name Colors.Blue) (Name Colors.Blue) (Length.ofInt 0) 1.0 1.0
        let radius = (s.range.distance / 10) + 1
        Circle.create centre (Length.ofInt radius)
        |> Element.createWithStyle style

    let beacon (s:Sensor) =
        let centre = point s.beacon
        let style = Style.create (Name Colors.Red) (Name Colors.Red) (Length.ofInt 0) 0.5 0.5
        let radius = (s.range.distance / 10) + 1
        Circle.create centre (Length.ofInt radius)
        |> Element.createWithStyle style


    let range (s:Sensor) =
        let points =
            seq {
                yield point s.range.top
                yield point s.range.left
                yield point s.range.bottom 
                yield point s.range.right          
            }
        let style = Style.create (Name Colors.Green) (Name Colors.Green) (Length.ofInt 0) 0.25 0.25

        points
        |> Polygon.ofSeq
        |> Element.createWithStyle style
    
    let plotSensor (s:Sensor) =
        seq {
            yield sensor s
            yield beacon s
            yield range s
        }

    let slices line (s: Slice seq) =
        let style = Style.create (Name Colors.Red) (Name Colors.Red) (Length.ofPercent 0.1) 1 1
        s 
        |> List.ofSeq
        |> List.map(fun it -> match it with Slice.Start s -> s | Slice.End e -> e )
        |> List.chunkBySize 2
        |> List.map(fun it -> Point.ofInts(it.[0], line), Point.ofInts(it.[1], line))
        |> List.map (fun (s,e) -> Line.create s e |> Element.createWithStyle style )


    let plot line (sensors:Sensor seq) =
        let tl, br = dimensions sensors
        let area = Area.fromPoints tl br
        let viewbox = ViewBox.create tl area

        let slice_el =
            sensors 
            |> Slice.intersect line
            |> slices line

        let sensor_el =
            sensors
            |> Seq.map plotSensor |> Seq.concat
        
        slice_el |> Seq.append sensor_el    
        |> Svg.ofSeq
        |> Svg.withViewBox viewbox
        |> showSvg
            

#!fsharp

let ResolutionFolder = __SOURCE_DIRECTORY__

let sensors =
    File.ReadLines( ResolutionFolder + "/input15.txt")
    |> Seq.map Sensor.parse

let line = 2000000
let intersect =
    sensors
    |> Slice.intersect line
    |> Slice.sum

display intersect

let found = sensors |> Sensor.beaconsAt line

display found

intersect - found

#!fsharp

sensors |> Preview.plot line
